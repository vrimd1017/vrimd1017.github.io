---
title: "Codility-001"
date: 2019-05-13 01:33:0 -0400
categories: Codility
---




Codility의 1번, 2번, 3번 문항을 풀어봤습니다.

![Codility__001](https://user-images.githubusercontent.com/48889645/57585707-b3f69700-7526-11e9-8fbf-16682bb3b43d.PNG)
1번 문제는 어떤 값이 들어왔을때, 해당 값을 2진으로 표현하여 1과 1사이에 있는 0의 개수.
즉, 1과 1사이의 gap이 가장 큰 부분을 찾는 문제였습니다.
처음에는 일일히 2로 나눠서 나머지를 저장해서 구현할까 생각하다가 정수를 2진수로 만들어주는 메서드
'Integer.toBinaryString()'가 있다는 것을 알았고,
이어서 1과 1 사이의 간격을 어떻게 구할까 생각하다가 이전에 한번 써보았던 StringTokenizer라는
클래스가 생각이 났었던, 그래서 이용할 수 있었던 문제풀이입니다.
결과는 26%인가 낮게 나왔지만요..

![Codility__002](https://user-images.githubusercontent.com/48889645/57585708-b78a1e00-7526-11e9-9ce5-e1564497892f.PNG)
2번 문제는 어떤 배열이 들어왔을 때, 그리고 해당 배열은 하나의 값을 제외하고는 모두 한쌍씩 존재한다고
가정했을때, 하나만 존재하는 해당 값을 찾는 문제입니다.
어떤식으로 표현을 해야될까 고민하다가 우선적으로 배열을 정렬시키고, 항상 한쌍이 있을것이기 때문에
한쌍이 아닌 값을 찾으면 되겠다라는 생각을 하게 되었습니다.
'Arrays.sort()'라는 메서드를 통해 제공된 배열을 정렬시키고 한쌍이 아닐때에 값의 앞뒤 비교를 통해
문제를 풀어내었습니다.

![Codility__003](https://user-images.githubusercontent.com/48889645/57585709-b953e180-7526-11e9-9029-c4a2f6bd5f8a.PNG)
3번문제는 배열과 특정 값이 주어지고, 해당 값만큼 배열을 오른쪽으로 이동시키는 문제였습니다.
물론 마지막 원소는 배열의 첫번째 인덱스로 들어가게됩니다.
정확성에 중점을 준다고 하여 아예 처음부터 하나하나 옮길까 싶다가 너무 오래걸리진 않을까 싶어 다시 생각했습니다.
오른쪽으로 n만큼 움직인 다는것을 오른쪽에서부터 n번째 값이 배열의 첫번째 원소가 된다는것을 뜻하기때문에
이를 이용하여 문제를 풀었었습니다.
다행히도, 70%가량의 값이 나왔습니다
